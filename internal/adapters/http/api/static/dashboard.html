<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CUJU Dashboard</title>
  <style>
    :root { --bg:#0b1220; --panel:#121a2b; --text:#e6edf3; --muted:#9fb3c8; --accent:#4f9cf9; --ok:#2ecc71; --warn:#f1c40f; --err:#e74c3c; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; background:var(--bg); color:var(--text); }
    header { padding:16px 20px; border-bottom:1px solid #1d2a44; position:sticky; top:0; background:rgba(11,18,32,.9); backdrop-filter: blur(6px); z-index:5; }
    h1 { margin:0; font-size:18px; font-weight:600; letter-spacing:.3px; }
    .subtitle { color:var(--muted); font-size:12px; margin-top:2px; }
    .controls { margin-top:10px; display:flex; gap:16px; align-items:center; flex-wrap:wrap; color:var(--muted); font-size:12px; }
    .controls label { color:#dce6f3; font-weight:600; font-size:12px; }
    .slider { display:flex; align-items:center; gap:10px; }
    input[type="range"]{ appearance:none; -webkit-appearance:none; width:200px; height:4px; background:#1b2944; border-radius:999px; outline:none; }
    input[type="range"]::-webkit-slider-thumb{ -webkit-appearance:none; appearance:none; width:14px; height:14px; background:var(--accent); border-radius:50%; cursor:pointer; }
    .pill { background:#0e1729; border:1px solid #1b2944; border-radius:999px; padding:4px 10px; color:#dce6f3; font-weight:600; font-size:12px; }
    .container { display:flex; flex-wrap:wrap; gap:12px; padding:12px; max-width:1400px; margin:0 auto; align-items:stretch; }
    .panel { background:var(--panel); border:1px solid #1b2944; border-radius:10px; padding:12px; overflow:hidden; min-height:220px; flex: 1 1 320px; }
    .panel.wide { flex: 1 1 640px; }
    .panel.tall canvas { height: clamp(240px, 34vh, 420px); }
    .panel h3 { margin:0 0 8px; font-size:13px; font-weight:600; color:#dce6f3; }
    .kpis { display:flex; flex-wrap:wrap; gap:12px; }
    .kpi { background:#0e1729; border:1px solid #1b2944; border-radius:10px; padding:12px; flex: 1 1 160px; }
    .kpi .label { font-size:11px; color:var(--muted); }
    .kpi .value { margin-top:6px; font-size:20px; font-weight:700; }
    canvas { width:100%; height: clamp(200px, 28vh, 360px); }
    .flow { display:flex; flex-wrap:wrap; gap:12px; }
    /* grid helpers removed; flex sizing via .panel widths */
    .footer { padding:16px; color:var(--muted); font-size:12px; text-align:center; }
    .status-dot{ display:inline-block; width:8px; height:8px; border-radius:50%; margin-right:6px; background:var(--warn); }
    .ok{ background:var(--ok); } .err{ background:var(--err); }
    .legend{ font-size:11px; color:var(--muted); display:flex; gap:12px; flex-wrap:wrap; }
    .legend span{ display:inline-flex; align-items:center; gap:6px; }
    .b{ font-weight:600; color:#dce6f3; }
    .panel.tall { max-height: 320px; }
    @media (max-width: 1200px) {
      .panel.wide { flex: 1 1 100%; }
    }
    @media (max-width: 900px) {
      .panel { flex: 1 1 100%; }
      .kpi .value { font-size:18px; }
    }
    @media (prefers-reduced-motion: reduce) {
      * { animation: none !important; transition: none !important; }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.6/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/luxon@3.5.0/build/global/luxon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.3.1/dist/chartjs-adapter-luxon.umd.min.js"></script>
  <script>
    async function fetchMetrics() {
      const r = await fetch('/healthz', { headers: { 'Accept': 'text/plain' } });
      const t = await r.text();
      return parsePrometheusText(t);
    }

    function parsePrometheusText(text) {
      const lines = text.split('\n');
      const metrics = {};
      const help = {};
      for (const line of lines) {
        if (!line || line.startsWith('# TYPE')) continue;
        if (line.startsWith('# HELP')) {
          const m = line.match(/^# HELP\s+(\S+)\s+(.*)$/);
          if (m) help[m[1]] = m[2];
          continue;
        }
        const m = line.match(/^(\w[\w:]*)(\{[^}]*\})?\s+(\d+(?:\.\d+)?(?:e[+-]?\d+)?)$/i);
        if (!m) continue;
        const name = m[1];
        const labels = m[2] || '';
        const value = parseFloat(m[3]);
        if (!metrics[name]) metrics[name] = [];
        metrics[name].push({ labels: parseLabels(labels), value });
      }
      return { metrics, help };
    }

    function parseLabels(labelStr) {
      const map = {};
      if (!labelStr) return map;
      const inner = labelStr.slice(1, -1);
      for (const kv of inner.split(',')) {
        const idx = kv.indexOf('=');
        if (idx < 0) continue;
        const k = kv.slice(0, idx).trim();
        const v = kv.slice(idx+1).trim().replace(/^"|"$/g, '');
        map[k] = v;
      }
      return map;
    }

    const charts = {};
    const endpointDatasetIndex = {}; // endpoint -> dataset index for API chart
    const endpointColors = ["#4f9cf9", "#2ecc71", "#f39c12", "#9b59b6", "#e74c3c", "#1abc9c", "#e67e22", "#95a5a6"];
    function colorForEndpoint(name) {
      const keys = Object.keys(endpointDatasetIndex);
      const idx = keys.indexOf(name);
      if (idx >= 0) return endpointColors[idx % endpointColors.length];
      const next = keys.length;
      endpointDatasetIndex[name] = next;
      return endpointColors[next % endpointColors.length];
    }

    function ensureChart(id, cfg) {
      if (charts[id]) return charts[id];
      const ctx = document.getElementById(id).getContext('2d');
      charts[id] = new Chart(ctx, cfg);
      return charts[id];
    }

    function timeSeriesConfig(label, color) {
      return {
        type: 'line',
        data: { datasets: [{ label, data: [], borderColor: color, tension: .25, fill: false, pointRadius: 0 }] },
        options: { responsive: true, maintainAspectRatio: false, animation:false, scales:{ x:{ type:'time', time:{ unit:'second' }, grid:{ color:'#1f2d4a'} }, y:{ min:0, grid:{ color:'#1f2d4a'} } }, plugins:{ legend:{ labels:{ color:'#dce6f3' } } } }
      };
    }

    function gaugeConfig(label, color) {
      return {
        type: 'doughnut',
        data: { labels:[label, ''], datasets:[{ data:[0,100], backgroundColor:[color,'#0e1729'], borderWidth:0, circumference: 270, rotation: 225, cutout: '70%' }] },
        options: { responsive:true, maintainAspectRatio:false, animation:false, plugins:{ legend:{ display:false }, tooltip:{ enabled:false } } }
      };
    }

    function updateGauge(chart, percent) {
      const v = Math.max(0, Math.min(100, percent));
      chart.data.datasets[0].data[0] = v;
      chart.data.datasets[0].data[1] = 100 - v;
      chart.update();
    }

    function sumValues(list) { return list.reduce((a,b)=>a + (b?.value||0), 0); }
    function getMetric(m, name) { return (m[name]||[]); }
    function firstValue(list) { return list.length ? (list[0]?.value||0) : 0; }
    function aggByEndpoint(rows) {
      const out = {};
      for (const row of rows) {
        const ep = (row.labels && row.labels.endpoint) ? row.labels.endpoint : 'unknown';
        out[ep] = (out[ep] || 0) + (row.value || 0);
      }
      return out;
    }

    let history = [];
    let refreshSeconds = 2; // default; clamped 2-10
    const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
    const maxPoints = 300; // keep a longer history; we trim dynamically
    const WINDOW_MS = 5 * 60 * 1000; // 5 minutes
    function pushHistory(point) {
      history.push(point);
      const cutoff = point.now - WINDOW_MS;
      while (history.length > 0 && history[0].now < cutoff) history.shift();
    }

    function trimSeries(chart, now) {
      const cutoff = now - WINDOW_MS;
      const data = chart.data.datasets[0].data;
      while (data.length > 0 && data[0].x < cutoff) data.shift();
    }

    function calcRate(seriesKey) {
      if (history.length < 2) return 0;
      const lastPoint = history[history.length-1];
      const prevPoint = history[history.length-2];
      const last = lastPoint[seriesKey] || 0;
      const prev = prevPoint[seriesKey] || 0;
      const dtSec = Math.max(0.001, (lastPoint.now - prevPoint.now) / 1000);
      return Math.max(0, (last - prev) / dtSec);
    }


    function calcEndpointRate(endpoint) {
      if (history.length < 2) return 0;
      const lastPoint = history[history.length-1];
      const prevPoint = history[history.length-2];
      const last = (lastPoint.endpointTotals && lastPoint.endpointTotals[endpoint]) || 0;
      const prev = (prevPoint.endpointTotals && prevPoint.endpointTotals[endpoint]) || 0;
      const dtSec = Math.max(0.001, (lastPoint.now - prevPoint.now) / 1000);
      return Math.max(0, (last - prev) / dtSec);
    }

    async function tick() {
      try {
        const { metrics: m } = await fetchMetrics();
        const now = Date.now();

        const httpReqs = getMetric(m, 'cuju_leaderboard_http_requests_total');
        const httpTotal = sumValues(httpReqs);
        // Build endpoint totals from labeled counter
        const endpointTotals = {};
        for (const row of httpReqs) {
          const ep = row.labels.endpoint || 'unknown';
          endpointTotals[ep] = (endpointTotals[ep] || 0) + (row.value || 0);
        }
        const httpDuration = sumValues(getMetric(m, 'cuju_leaderboard_http_request_duration_milliseconds_bucket'));
        const httpDurSumByEp = aggByEndpoint(getMetric(m, 'cuju_leaderboard_http_request_duration_milliseconds_sum'));
        const httpDurCountByEp = aggByEndpoint(getMetric(m, 'cuju_leaderboard_http_request_duration_milliseconds_count'));
        const queueSize = sumValues(getMetric(m, 'cuju_leaderboard_queue_size'));
        const queueCap = sumValues(getMetric(m, 'cuju_leaderboard_queue_capacity')) || 1;
        const queueUtil = sumValues(getMetric(m, 'cuju_leaderboard_queue_utilization_ratio')) * 100;
        const enqTotal = sumValues(getMetric(m, 'cuju_leaderboard_queue_enqueue_total'));
        const deqTotal = sumValues(getMetric(m, 'cuju_leaderboard_queue_dequeue_total'));
        const workers = sumValues(getMetric(m, 'cuju_leaderboard_worker_count'))
                       || sumValues(getMetric(m, 'cuju_leaderboard_worker_active_count')) + sumValues(getMetric(m, 'cuju_leaderboard_worker_idle_count'));
        const workerMps = sumValues(getMetric(m, 'cuju_leaderboard_worker_messages_per_second'));
        const eventsProcessed = sumValues(getMetric(m, 'cuju_leaderboard_events_processed_total'));
        const eventsDup = sumValues(getMetric(m, 'cuju_leaderboard_events_duplicate_total'));
        const repoRecords = sumValues(getMetric(m, 'cuju_leaderboard_repository_records_total'));
        const repoShards = sumValues(getMetric(m, 'cuju_leaderboard_repository_shard_count'));
        const snapLastUnix = firstValue(getMetric(m, 'cuju_leaderboard_repository_snapshot_last_unix'));
        const snapLastDurMs = firstValue(getMetric(m, 'cuju_leaderboard_repository_snapshot_last_duration_milliseconds'));
        const snapCount = sumValues(getMetric(m, 'cuju_leaderboard_repository_snapshot_count_total'));

        pushHistory({ now, httpTotal, eventsProcessed, repoRecords, enqTotal, deqTotal, endpointTotals, endpointLatencySum: httpDurSumByEp, endpointLatencyCount: httpDurCountByEp });

        const apiRps = calcRate('httpTotal');
        const eventsRps = calcRate('eventsProcessed');
        const enqRps = calcRate('enqTotal');
        const deqRps = calcRate('deqTotal');
        const backlogDelta = enqRps - deqRps;

        document.getElementById('k-http-total').textContent = httpTotal.toLocaleString();
        document.getElementById('k-api-rps').textContent = apiRps.toFixed(1);
        document.getElementById('k-queue-size').textContent = queueSize.toLocaleString();
        document.getElementById('k-workers').textContent = workers.toLocaleString();
        document.getElementById('k-events').textContent = eventsProcessed.toLocaleString();
        document.getElementById('k-dupes').textContent = eventsDup.toLocaleString();
        document.getElementById('k-records').textContent = repoRecords.toLocaleString();

        // Flow Overview values
        const utilPct = Math.max(0, Math.min(100, Math.round((queueSize / queueCap) * 100)));
        const snapTimeStr = snapLastUnix ? new Date(snapLastUnix * 1000).toLocaleTimeString() : '-';
        document.getElementById('f-api-rps').textContent = apiRps.toFixed(1);
        document.getElementById('f-enq-rps').textContent = enqRps.toFixed(1);
        document.getElementById('f-queue-size').textContent = queueSize.toLocaleString();
        document.getElementById('f-queue-util').textContent = isFinite(utilPct) ? (utilPct + '%') : '0%';
        document.getElementById('f-deq-rps').textContent = deqRps.toFixed(1);
        document.getElementById('f-worker-mps').textContent = workerMps.toFixed(1);
        document.getElementById('f-records').textContent = repoRecords.toLocaleString();
        document.getElementById('f-backlog-delta').textContent = (backlogDelta>=0?'+':'') + backlogDelta.toFixed(1) + ' rps';

        // Charts
        // API Calls chart per endpoint
        const apiCallsChart = ensureChart('c-api-calls', {
          type: 'line',
          data: { datasets: [] },
          options: { responsive: true, maintainAspectRatio:false, animation:false, scales:{ x:{ type:'time', time:{ unit:'second' }, grid:{ color:'#1f2d4a'} }, y:{ min:0, grid:{ color:'#1f2d4a'} } }, plugins:{ legend:{ labels:{ color:'#dce6f3' } } } }
        });
        // Ensure a dataset exists for each endpoint seen
        const endpoints = Object.keys(endpointTotals).sort();
        for (const ep of endpoints) {
          if (apiCallsChart.data.datasets.findIndex(d => d.label === ep) === -1) {
            apiCallsChart.data.datasets.push({ label: ep, data: [], borderColor: colorForEndpoint(ep), tension: .25, fill: false, pointRadius: 0 });
          }
        }
        // Append current rates
        for (const ds of apiCallsChart.data.datasets) {
          const ep = ds.label;
          const rps = calcEndpointRate(ep);
          ds.data.push({ x: now, y: Math.max(0, rps) });
          // Trim history to window
          while (ds.data.length > 0 && ds.data[0].x < now - WINDOW_MS) ds.data.shift();
        }
        trimSeries(apiCallsChart, now);
        apiCallsChart.update();

        // API Response Time (ms) chart per endpoint (rolling average from histogram deltas)
        const apiLatencyChart = ensureChart('c-api-latency', {
          type: 'line',
          data: { datasets: [] },
          options: { responsive: true, maintainAspectRatio:false, animation:false,
            scales:{ x:{ type:'time', time:{ unit:'second' }, grid:{ color:'#1f2d4a'} }, y:{ min:0, grid:{ color:'#1f2d4a'} } },
            plugins:{ legend:{ labels:{ color:'#dce6f3' } } }
          }
        });
        const prev = history.length >= 2 ? history[history.length-2] : null;
        const rtEndpoints = Object.keys(httpDurSumByEp).sort();
        for (const ep of rtEndpoints) {
          if (apiLatencyChart.data.datasets.findIndex(d => d.label === ep) === -1) {
            apiLatencyChart.data.datasets.push({ label: ep, data: [], borderColor: colorForEndpoint(ep), tension: .25, fill: false, pointRadius: 0 });
          }
        }
        for (const ds of apiLatencyChart.data.datasets) {
          const ep = ds.label;
          const currSum = httpDurSumByEp[ep] || 0;
          const currCnt = httpDurCountByEp[ep] || 0;
          const prevSum = prev && prev.endpointLatencySum ? (prev.endpointLatencySum[ep] || 0) : 0;
          const prevCnt = prev && prev.endpointLatencyCount ? (prev.endpointLatencyCount[ep] || 0) : 0;
          const dCnt = currCnt - prevCnt;
          const dSum = currSum - prevSum;
          if (dCnt > 0 && dSum >= 0 && isFinite(dSum / dCnt)) {
            ds.data.push({ x: now, y: Math.max(0, dSum / dCnt) });
          }
          while (ds.data.length > 0 && ds.data[0].x < now - WINDOW_MS) ds.data.shift();
        }
        trimSeries(apiLatencyChart, now);
        apiLatencyChart.update();

        const eventsChart = ensureChart('c-events', timeSeriesConfig('Events/s', '#2ecc71'));
        eventsChart.data.datasets[0].data.push({ x: now, y: Math.max(0, eventsRps) });
        trimSeries(eventsChart, now);
        eventsChart.update();


        const recordsChart = ensureChart('c-records', timeSeriesConfig('Records', '#16a085'));
        recordsChart.data.datasets[0].data.push({ x: now, y: Math.max(0, repoRecords) });
        trimSeries(recordsChart, now);
        recordsChart.update();


      } catch (e) {
        console.error(e);
        document.getElementById('status-dot').classList.remove('ok');
        document.getElementById('status-dot').classList.add('err');
      }
    }

    function applyRefresh(seconds) {
      refreshSeconds = clamp(Number(seconds)||2, 2, 10);
      localStorage.setItem('dashboardRefreshSec', String(refreshSeconds));
      document.getElementById('refresh-value').textContent = refreshSeconds + 's';
      document.getElementById('footer-refresh').textContent = refreshSeconds + 's';
    }

    let intervalHandle = null;
    async function start() {
      document.getElementById('status-dot').classList.add('ok');
      const saved = Number(localStorage.getItem('dashboardRefreshSec'));
      applyRefresh(isNaN(saved) ? 2 : saved);
      const slider = document.getElementById('refresh-interval');
      slider.value = String(refreshSeconds);
      slider.addEventListener('input', (e)=>{
        applyRefresh(e.target.value);
        if (intervalHandle) clearInterval(intervalHandle);
        intervalHandle = setInterval(tick, refreshSeconds * 1000);
      });
      await tick();
      intervalHandle = setInterval(tick, refreshSeconds * 1000);
    }
    window.addEventListener('load', start);
  </script>
</head>
<body>
  <header>
    <h1><span id="status-dot" class="status-dot"></span> CUJU Operational Dashboard <a href="/api-docs" style="color: var(--accent); text-decoration: none; font-size: 14px; font-weight: normal; margin-left: 12px;">📚 API Docs</a></h1>
    <div class="subtitle">Live metrics scraped from <span class="b">/healthz</span></div>
    <div class="controls" id="refresh-control">
      <label for="refresh-interval">Refresh interval</label>
      <div class="slider">
        <input id="refresh-interval" name="refreshInterval" type="range" min="2" max="10" step="1" value="2" aria-label="Refresh interval (seconds)" />
        <span class="pill" id="refresh-value">2s</span>
      </div>
    </div>
  </header>

  <div class="container">
    <div class="panel wide">
      <h3>Flow Overview (API → Queue → Workers → Repository)</h3>
      <div class="kpis flow">
        <div class="kpi"><div class="label">API RPS</div><div class="value" id="f-api-rps">-</div></div>
        <div class="kpi"><div class="label">Enqueue RPS</div><div class="value" id="f-enq-rps">-</div></div>
        <div class="kpi"><div class="label">Queue Size</div><div class="value" id="f-queue-size">-</div></div>
        <div class="kpi"><div class="label">Queue Util</div><div class="value" id="f-queue-util">-</div></div>
        <div class="kpi"><div class="label">Dequeue RPS</div><div class="value" id="f-deq-rps">-</div></div>
        <div class="kpi"><div class="label">Worker MPS</div><div class="value" id="f-worker-mps">-</div></div>
        <div class="kpi"><div class="label">Repo Records</div><div class="value" id="f-records">-</div></div>
        <div class="kpi"><div class="label">Backlog ΔRPS</div><div class="value" id="f-backlog-delta">-</div></div>
      </div>
    </div>
    <div class="panel wide tall">
      <h3>API Calls per Second</h3>
      <canvas id="c-api-calls"></canvas>
    </div>

    <div class="panel">
      <h3>Key KPIs</h3>
      <div class="kpis">
        <div class="kpi"><div class="label">Total API Requests</div><div class="value" id="k-http-total">-</div></div>
        <div class="kpi"><div class="label">API RPS</div><div class="value" id="k-api-rps">-</div></div>
        <div class="kpi"><div class="label">Queue Size</div><div class="value" id="k-queue-size">-</div></div>
        <div class="kpi"><div class="label">Workers</div><div class="value" id="k-workers">-</div></div>
        <div class="kpi"><div class="label">Events Processed</div><div class="value" id="k-events">-</div></div>
        <div class="kpi"><div class="label">Duplicate Events</div><div class="value" id="k-dupes">-</div></div>
        <div class="kpi"><div class="label">Repository Records</div><div class="value" id="k-records">-</div></div>
      </div>
    </div>
    <div class="panel wide tall">
      <h3>API Response Time (ms)</h3>
      <canvas id="c-api-latency"></canvas>
    </div>
    <div class="panel wide tall">
      <h3>Events per Second</h3>
      <canvas id="c-events"></canvas>
    </div>
    <div class="panel wide tall">
      <h3>Repository Records Over Time</h3>
      <canvas id="c-records"></canvas>
    </div>
  </div>

  <div class="footer">CUJU Dashboard • data from /healthz • refreshed every <span id="footer-refresh">2s</span></div>
</body>
</html>


