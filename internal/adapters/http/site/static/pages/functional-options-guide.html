<!doctype html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="./assets/site.css"><title>CUJU Functional Options Guide</title></head><body><div class="layout"><aside id="sidebar"></aside><main><article><h1>CUJU Functional Options Guide</h1>
<p>This guide documents the functional options pattern implementation across all CUJU packages, providing flexible and extensible configuration for every component.</p>
<h2>Overview</h2>
<p>The functional options pattern allows you to configure components with a clean, readable API while maintaining sensible defaults. Each package provides a set of `With*` functions that can be combined to create custom configurations.</p>
<h2>Package: Queue</h2>
<p>The `internal/queue` package provides configuration options for the in-memory event queue.</p>
<h3>Available Options</h3>
<p><pre><code>go
// WithCapacity sets the queue capacity
queue.NewInMemoryQueue(queue.WithCapacity(500000))

// WithBufferSize sets the buffer size for the events channel
queue.NewInMemoryQueue(queue.WithBufferSize(250000))</code></pre></p>
<h3>Default Values</h3>
<ul>
<li>**Capacity**: 100,000</li>
<ul>
<li>**Buffer Size**: 100,000</li>
</ul>
<h3>Example Usage</h3>
<p><pre><code>go
eventQueue := queue.NewInMemoryQueue(
    queue.WithCapacity(1000000),
    queue.WithBufferSize(500000),
)</code></pre></p>
<h2>Package: Dedupe</h2>
<p>The `internal/dedupe` package provides configuration options for event deduplication.</p>
<h3>Available Options</h3>
<p><pre><code>go
// WithMaxSize sets the maximum number of IDs to keep in memory
dedupe.NewInMemoryDeduper(dedupe.WithMaxSize(100000))</code></pre></p>
<h3>Default Values</h3>
<ul>
<li>**Max Size**: 50,000</li>
</ul>
<h3>Example Usage</h3>
<p><pre><code>go
deduper := dedupe.NewInMemoryDeduper(
    dedupe.WithMaxSize(200000),
)</code></pre></p>
<h2>Package: Leaderboard</h2>
<p>The `internal/leaderboard` package provides configuration options for the treap-based leaderboard store.</p>
<h3>Available Options</h3>
<p><pre><code>go
// WithShardCount sets the number of shards for the leaderboard store
leaderboard.NewTreapStore(leaderboard.WithShardCount(8))

// WithSnapshotInterval sets the interval for publishing snapshots
leaderboard.NewTreapStore(leaderboard.WithSnapshotInterval(500*time.Millisecond))

// WithTopCacheSize sets the size of the top-K cache
leaderboard.NewTreapStore(leaderboard.WithTopCacheSize(5000))</code></pre></p>
<h3>Default Values</h3>
<ul>
<li>**Shard Count**: 16</li>
<ul>
<li>**Snapshot Interval**: 2 seconds</li>
<ul>
<li>**Top Cache Size**: 200</li>
</ul>
<h3>Example Usage</h3>
<p><pre><code>go
store := leaderboard.NewTreapStore(
    leaderboard.WithShardCount(16),
    leaderboard.WithSnapshotInterval(250*time.Millisecond),
    leaderboard.WithTopCacheSize(10000),
)</code></pre></p>
<h2>Package: Scoring</h2>
<p>The `internal/scoring` package provides configuration options for the ML scoring service.</p>
<h3>Available Options</h3>
<p><pre><code>go
// WithSkillWeights sets the skill-specific scoring weights
scoring.NewInMemoryScorer(scoring.WithSkillWeights(map[string]float64{
    &quot;coding&quot;: 1.2,
    &quot;design&quot;: 1.0,
}))

// WithLatencyRange sets the simulated latency range
scoring.NewInMemoryScorer(scoring.WithLatencyRange(5*time.Millisecond, 50*time.Millisecond))

// WithRandomSeed sets the random seed for deterministic scoring
scoring.NewInMemoryScorer(scoring.WithRandomSeed(12345))

// WithDefaultWeight sets the default weight for unknown skills
scoring.NewInMemoryScorer(scoring.WithDefaultWeight(0.6))

// WithScoringAlgorithm sets the scoring algorithm for a specific skill
scoring.NewInMemoryScorer(scoring.WithScoringAlgorithm(&quot;coding&quot;, scoring.ScoringAlgorithmExponential))

// WithMetrics enables metrics collection
scoring.NewInMemoryScorer(scoring.WithMetrics(true))</code></pre></p>
<h3>Scoring Algorithms</h3>
<ul>
<li>**Linear**: Standard linear scoring</li>
<ul>
<li>**Logarithmic**: Logarithmic scaling for creativity</li>
<ul>
<li>**Exponential**: Exponential growth for high metrics</li>
<ul>
<li>**Custom**: Custom algorithm implementation</li>
</ul>
<h3>Default Values</h3>
<ul>
<li>**Skill Weights**: coding(1.0), design(0.8), writing(0.9), marketing(0.7), sales(0.6)</li>
<ul>
<li>**Default Weight**: 0.5</li>
<ul>
<li>**Min Latency**: 10ms</li>
<ul>
<li>**Max Latency**: 100ms</li>
<ul>
<li>**Random Seed**: 42</li>
<ul>
<li>**Metrics**: false</li>
</ul>
<h3>Example Usage</h3>
<p><pre><code>go
scorer := scoring.NewInMemoryScorer(
    scoring.WithSkillWeights(map[string]float64{
        &quot;coding&quot;:    1.2,
        &quot;design&quot;:    1.0,
        &quot;writing&quot;:   0.9,
        &quot;marketing&quot;: 0.8,
        &quot;sales&quot;:     0.7,
    }),
    scoring.WithLatencyRange(5*time.Millisecond, 50*time.Millisecond),
    scoring.WithRandomSeed(12345),
    scoring.WithDefaultWeight(0.6),
    scoring.WithScoringAlgorithm(&quot;coding&quot;, scoring.ScoringAlgorithmExponential),
    scoring.WithScoringAlgorithm(&quot;design&quot;, scoring.ScoringAlgorithmLogarithmic),
    scoring.WithMetrics(true),
)</code></pre></p>
<h2>Package: Worker</h2>
<p>The `internal/worker` package provides configuration options for event processing workers.</p>
<h3>Available Options</h3>
<p><pre><code>go
// WithName sets the worker name for identification and logging
worker.NewInMemoryWorker(queue, scorer, updater, worker.WithName(&quot;high-performance-worker&quot;))

// WithLogger sets a custom logger for the worker
worker.NewInMemoryWorker(queue, scorer, updater, worker.WithLogger(logger.Named(&quot;worker&quot;)))

// WithName sets the worker name for identification and logging
worker.NewInMemoryWorker(queue, scorer, updater, worker.WithName("high-performance-worker"))

// WithLogger sets a custom logger for the worker
worker.NewInMemoryWorker(queue, scorer, updater, worker.WithLogger(logger.Named("worker")))</code></pre></p>
<h3>Default Values</h3>
<ul>
<li>**Name**: "worker"</li>
</ul>
<h3>Example Usage</h3>
<p><pre><code>go
eventWorker := worker.NewInMemoryWorker(
    eventQueue,
    scorer,
    updater,
    worker.WithName(&quot;high-performance-worker&quot;),
    worker.WithLogger(logger.Named(&quot;worker&quot;)),
)</code></pre></p>
<h2>Package: Metrics</h2>
<p>The `internal/metrics` package provides configuration options for Prometheus metrics.</p>
<h3>Available Options</h3>
<p><pre><code>go
// WithNamespace sets the namespace for all metrics
metrics.NewMetricsManager(metrics.WithNamespace(&quot;cuju&quot;))

// WithSubsystem sets the subsystem for all metrics
metrics.NewMetricsManager(metrics.WithSubsystem(&quot;leaderboard&quot;))

// WithHistogramBuckets sets custom histogram buckets for latency metrics
metrics.NewMetricsManager(metrics.WithHistogramBuckets([]float64{0.001, 0.01, 0.1, 1, 10, 100}))

// WithMetricsEnabled enables or disables metrics collection
metrics.NewMetricsManager(metrics.WithMetricsEnabled(true))

// WithRefreshInterval sets the interval for updating gauge metrics
metrics.NewMetricsManager(metrics.WithRefreshInterval(5*time.Second))

// WithCustomLabels adds custom labels to all metrics
metrics.NewMetricsManager(metrics.WithCustomLabels(map[string]string{
    &quot;environment&quot;: &quot;production&quot;,
    &quot;version&quot;:     &quot;1.0.0&quot;,
}))

// WithMetricPrefix sets a custom prefix for metric names
metrics.NewMetricsManager(metrics.WithMetricPrefix(&quot;cuju_custom&quot;))

// WithPrometheusRegistry sets a custom Prometheus registry
metrics.NewMetricsManager(metrics.WithPrometheusRegistry(customRegistry))</code></pre></p>
<h3>Default Values</h3>
<ul>
<li>**Namespace**: "cuju"</li>
<ul>
<li>**Subsystem**: "leaderboard"</li>
<ul>
<li>**Histogram Buckets**: prometheus.DefBuckets</li>
<ul>
<li>**Metrics Enabled**: true</li>
<ul>
<li>**Refresh Interval**: 10 seconds</li>
<ul>
<li>**Custom Labels**: empty map</li>
<ul>
<li>**Metric Prefix**: "cuju"</li>
<ul>
<li>**Registry**: prometheus.DefaultRegisterer</li>
</ul>
<h3>Example Usage</h3>
<p><pre><code>go
metricsManager := metrics.NewMetricsManager(
    metrics.WithNamespace(&quot;cuju&quot;),
    metrics.WithSubsystem(&quot;leaderboard&quot;),
    metrics.WithHistogramBuckets([]float64{0.001, 0.01, 0.1, 1, 10, 100}),
    metrics.WithMetricsEnabled(true),
    metrics.WithRefreshInterval(5*time.Second),
    metrics.WithCustomLabels(map[string]string{
        &quot;environment&quot;: &quot;production&quot;,
        &quot;version&quot;:     &quot;1.0.0&quot;,
        &quot;region&quot;:      &quot;us-west-2&quot;,
    }),
    metrics.WithMetricPrefix(&quot;cuju_custom&quot;),
)</code></pre></p>
<h2>Package: Service</h2>
<p>The `internal/service` package provides configuration options for the main leaderboard service.</p>
<h3>Available Options</h3>
<p><pre><code>go
// WithLogger sets a custom logger for the service
service.New(service.WithLogger(logger))

// WithWorkerCount sets the number of worker goroutines
service.New(service.WithWorkerCount(16))

// WithQueueSize sets the maximum size of the event queue
service.New(service.WithQueueSize(1000000))

// WithDedupeSize sets the size of the deduplication cache
service.New(service.WithDedupeSize(200000))

// WithShardCount sets the number of shards for the leaderboard store
service.New(service.WithShardCount(8))</code></pre></p>
<h3>Default Values</h3>
<ul>
<li>**Worker Count**: runtime.NumCPU() * 2</li>
<ul>
<li>**Queue Size**: 100,000</li>
<ul>
<li>**Dedupe Size**: 50,000</li>
<ul>
<li>**Shard Count**: 4</li>
<ul>
<li>**Logger**: zap.NewNop()</li>
</ul>
<h3>Example Usage</h3>
<p><pre><code>go
svc := service.New(
    service.WithLogger(logger),
    service.WithWorkerCount(32),
    service.WithQueueSize(1000000),
    service.WithDedupeSize(500000),
    service.WithShardCount(16),
)</code></pre></p>
<h2>Environment-Based Configuration</h2>
<p>You can easily create environment-specific configurations:</p>
<p><pre><code>go
func getServiceConfig(env string) []service.Option {
    switch env {
    case &quot;development&quot;:
        return []service.Option{
            service.WithWorkerCount(4),
            service.WithQueueSize(10000),
            service.WithDedupeSize(5000),
            service.WithShardCount(2),
        }
    case &quot;staging&quot;:
        return []service.Option{
            service.WithWorkerCount(8),
            service.WithQueueSize(100000),
            service.WithDedupeSize(50000),
            service.WithShardCount(4),
        }
    case &quot;production&quot;:
        return []service.Option{
            service.WithWorkerCount(32),
            service.WithQueueSize(1000000),
            service.WithDedupeSize(500000),
            service.WithShardCount(16),
        }
    default:
        return []service.Option{}
    }
}

// Usage
svc := service.New(getServiceConfig(os.Getenv(&quot;ENV&quot;))...)</code></pre></p>
<h2>Builder Pattern</h2>
<p>For complex configurations, you can use the builder pattern:</p>
<p><pre><code>go
type ServiceConfig struct {
    workerCount int
    queueSize   int
    dedupeSize  int
    shardCount  int
    logger      *zap.Logger
}

func NewServiceConfig() *ServiceConfig {
    return &amp;ServiceConfig{
        workerCount: runtime.NumCPU() * 2,
        queueSize:   100000,
        dedupeSize:  50000,
        shardCount:  4,
    }
}

func (c *ServiceConfig) WithWorkerCount(count int) *ServiceConfig {
    if count &gt; 0 {
        c.workerCount = count
    }
    return c
}

func (c *ServiceConfig) WithQueueSize(size int) *ServiceConfig {
    if size &gt; 0 {
        c.queueSize = size
    }
    return c
}

func (c *ServiceConfig) WithDedupeSize(size int) *ServiceConfig {
    if size &gt; 0 {
        c.dedupeSize = size
    }
    return c
}

func (c *ServiceConfig) WithShardCount(count int) *ServiceConfig {
    if count &gt; 0 {
        c.shardCount = count
    }
    return c
}

func (c *ServiceConfig) WithLogger(logger *zap.Logger) *ServiceConfig {
    if logger != nil {
        c.logger = logger
    }
    return c
}

func (c *ServiceConfig) Build() []service.Option {
    var opts []service.Option
    
    if c.workerCount &gt; 0 {
        opts = append(opts, service.WithWorkerCount(c.workerCount))
    }
    if c.queueSize &gt; 0 {
        opts = append(opts, service.WithQueueSize(c.queueSize))
    }
    if c.dedupeSize &gt; 0 {
        opts = append(opts, service.WithDedupeSize(c.dedupeSize))
    }
    if c.shardCount &gt; 0 {
        opts = append(opts, service.WithShardCount(c.shardCount))
    }
    if c.logger != nil {
        opts = append(opts, service.WithLogger(c.logger))
    }
    
    return opts
}

// Usage
config := NewServiceConfig().
    WithWorkerCount(16).
    WithQueueSize(500000).
    WithDedupeSize(100000).
    WithShardCount(8).
    WithLogger(logger)

svc := service.New(config.Build()...)</code></pre></p>
<h2>Best Practices</h2>
<p>1. **Use Sensible Defaults**: All packages provide sensible defaults, so you only need to specify what you want to change.</p>
<p>2. **Combine Options**: You can combine multiple options to create the exact configuration you need.</p>
<p>3. **Environment Variables**: Use environment variables with functional options for dynamic configuration.</p>
<p>4. **Validation**: Always validate configurations, especially when they come from external sources.</p>
<p>5. **Documentation**: Document your configuration choices and their rationale.</p>
<p>6. **Testing**: Test different configuration combinations to ensure they work as expected.</p>
<h2>Migration Guide</h2>
<p>If you're migrating from the old constructor signatures:</p>
<h3>Before (Old API)</h3>
<p><pre><code>go
// Old way
queue := queue.NewInMemoryQueue(100000)
deduper := dedupe.NewInMemoryDeduper(50000)
store := leaderboard.NewTreapStore(4)
scorer := scoring.NewInMemoryScorer()
worker := worker.NewInMemoryWorker(&quot;worker&quot;, queue, scorer, updater)</code></pre></p>
<h3>After (New API)</h3>
<p><pre><code>go
// New way
queue := queue.NewInMemoryQueue(queue.WithCapacity(100000))
deduper := dedupe.NewInMemoryDeduper(dedupe.WithMaxSize(50000))
store := leaderboard.NewTreapStore(leaderboard.WithShardCount(4))
scorer := scoring.NewInMemoryScorer()
worker := worker.NewInMemoryWorker(queue, scorer, updater, worker.WithName(&quot;worker&quot;))</code></pre></p>
<h2>Conclusion</h2>
<p>The functional options pattern provides a clean, extensible way to configure all CUJU components. It maintains backward compatibility while adding powerful configuration capabilities. Each package follows the same pattern, making the API consistent and easy to use.</p>
<p>For more examples and advanced usage patterns, see the `examples/` directory and the individual package documentation.</p>
</article></main></div><script src="./assets/site.js"></script></body></html>